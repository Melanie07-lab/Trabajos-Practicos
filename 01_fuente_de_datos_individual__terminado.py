# -*- coding: utf-8 -*-
"""01/Fuente de Datos/Individual _TERMINADO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EgyC2U15-Z4ISP-gqLEiEKl3_2uOcDwk

[texto del vínculo](https://)*   **Año:** 2024
*   **Alumno/a:** Melanie Sampayo
*   **Legajo:** [LEGAJO]

# Archivos de texto plano

[gutenberg.org](https://www.gutenberg.org/) (llamado así por el inventor de la imprenta moderna) es el sitio web del Proyecto Gutenberg que se dedica a la distribución y creación de eBooks. En este sitio se encuentra el [Don Quijote](https://www.gutenberg.org/ebooks/14859). El Don Quijote se puede leer en diferentes formatos, ¿no? Para la tarea, se va a usar el Don Quijote de texto plano. La siguiente celda descarga el .txt y lo guarda en el sistema para luego su futura lectura:
"""

!wget https://www.gutenberg.org/cache/epub/2000/pg2000.txt

"""## Consignas

***NOTA: Para estas consignas, no se puede usar modulos externos a Python***

Del archivo descargado, calcular la cantidad de lineas:
"""

archive=open("pg2000.txt")
lineas=archive.readlines()
archive.close()

linea=0
ls=[]
s=len(lineas)
print(s)
#for line in lineas [:5]:
  #print(line)
  #ls.append(line)
  #for x in ls:
    #if line=="\n":
      #linea=linea+1
#print(linea)

"""Del archivo descargado, calcular la cantidad de veces que se dice:
*   'Quijote'
*   'mancha'
*   'españa'

Considerar que, por ejemplo, 'QuiJoTe' es lo mismo que 'quijote' (no *case sensitive*).
"""

contadores = {"quijote": 0, "mancha": 0, "españa": 0}
for linea in lineas:
   linea = linea.lower()
   for palabra in contadores:
    contadores[palabra] += linea.count(palabra)


for palabra, conteo in contadores.items():
    print(f"La palabra '{palabra}' aparece {conteo} veces.")

"""¿Quien es el autor y titulo del libro? Responderlo usando las herramientas utilizadas en la celda anterior (Tip: abrir el archivo de texto y ver como son las primeras lineas)."""

archive=open("pg2000.txt")
lsarch=archive.readlines()
archive.close()

x=lsarch[10:14]
print(x)

"""# Archivos .csv

*Robert* De Niro actuó en mas de 100 peliculas y Rotten Tomatoes es un sitio web en el que se pueden leer criticas y ratings a peliculas hechos por críticos y usuarios. La siguiente linea descarga un archivo .csv en el que tenemos peliculas de De Niro junto a su rating en Rotten Tomatoes:
"""

!wget https://people.sc.fsu.edu/~jburkardt/data/csv/deniro.csv

"""## Consignas

***NOTA: Apartir de aca, se pueden usar modulos externos de Python***

Sabemos que el archivo tiene en su primera linea los 'headers'. ¿Cuales son? Imprimirlos.
"""

archive=open("deniro.csv")
lsarch=archive.readlines()
archive.close()

x=lsarch[0]
print(x)

"""Convertir la información del archivo .csv a un diccionario."""

di = {}
ls_year = []
ls_score = []
ls_title = []


for line in lsarch[1:]:
    columns = line.strip().split(",")


    if len(columns) < 3:
        print(f"Línea ignorada por formato inesperado: {line.strip()}")
        continue
    year = columns[0]
    score = columns[1]
    title = columns[2]


    ls_year.append(year)
    ls_score.append(score)
    ls_title.append(title)


di["Year"] = ls_year
di["Score"] = ls_score
di["Title"] = ls_title


print(di)

"""¿Cuantas peliculas hay registradas en el archivo .csv?"""

cine=len(lsarch[1:])
print(cine)

"""Imprimir las peliculas mejor y peor rankeadas del archivo (imprimir sus respectivos rankings)"""

mayor = 0
peor = 100
peli_mejor = ""
peli_peor = ""

for i in range(len(di['Score'])):
    score = int(di['Score'][i])
    if score > mayor:
        mayor = score
        peli_mejor = di["Title"][i]
    if score < peor:
        peor = score
        peli_peor = di["Title"][i]

print(f"La película con el mejor ranking es '{peli_mejor}' con un puntaje de {mayor}.")
print(f"La película con el peor ranking es '{peli_peor}' con un puntaje de {peor}.")

"""# Base de datos - Relacionales

SQLite es una biblioteca de C que provee una base de datos ligera basada en disco que no requiere un proceso de servidor separado y permite acceder a la base de datos usando una variación no estándar del lenguaje de consulta SQL. Algunas aplicaciones pueden usar SQLite para almacenamiento interno. También es posible prototipar una aplicación usando SQLite y luego transferir el código a una base de datos más grande como PostgreSQL u Oracle.

Realizamos el `import` e indicamos el archivo en el que vamos a guardar la base de datos:
"""

import sqlite3
conn = sqlite3.connect('db.db')

"""La siguiente linea de codigo agrega filas a la misma. Por favor, ejecutar la siguiente celda para la consigna:


"""

import sqlite3

# Crear una nueva conexión si está cerrada
conn = sqlite3.connect('db.db')
cur = conn.cursor()
cur.execute("CREATE TABLE IF NOT EXISTS t (GameNumber TEXT, GameLength TEXT);")
with open('snakes_count_10000.csv','r') as csv_file:
  lines = csv_file.readlines()[1:]
  lines = [l.split(',') for l in lines]
  to_db = [(l[0].strip(), l[1].strip()) for l in lines]

cur.executemany("INSERT INTO t (GameNumber, GameLength) VALUES (?, ?);", to_db)
conn.commit()
conn.close()

!wget https://people.sc.fsu.edu/~jburkardt/data/csv/snakes_count_10000.csv

cur = conn.cursor()
cur.execute("CREATE TABLE t (GameNumber, GameLength);")

with open('snakes_count_10000.csv','r') as csv_file:
  lines = csv_file.readlines()[1:]
  lines = [l.split(',') for l in lines]
  to_db = [(l[0].strip(), l[1].strip()) for l in lines]

cur.executemany("INSERT INTO t (GameNumber, GameLength) VALUES (?, ?);", to_db)
conn.commit()
conn.close()

"""## Consignas

¿Como luce la base de datos? Imprimirla.
"""

import sqlite3
conn = sqlite3.connect('db.db')
cur = conn.cursor()

cur.execute("SELECT * FROM t;")


rows = cur.fetchall()

for row in rows:
    print(row)

conn.close()

"""¿Cuantas filas hay en la base de datos?"""

import sqlite3

conn = sqlite3.connect('db.db')
cur = conn.cursor()
cur.execute("SELECT COUNT(*) FROM t;")
num_filas = cur.fetchone()[0]
print(f"El número de filas en la base de datos es: {num_filas}")
conn.close()

"""¿Cual es el máximo `GameLength` y en qué `GameNumber` se realizó?"""

import sqlite3
conn = sqlite3.connect('db.db')
cur = conn.cursor()
cur.execute("SELECT GameNumber, GameLength FROM t ORDER BY GameLength DESC LIMIT 1;")
max_game = cur.fetchone()
print(f"El máximo GameLength es {max_game[1]} y ocurrió en el GameNumber {max_game[0]}")
conn.close()

"""# API Requests
Por lo general, conseguimos datos a traves de internet. Aunque el concepto de Application Programming Interface (API) es muy amplio y muy poco concreto, en el contexto de los servidores, es un conjunto de 'endpoints' que los servidores ofrecen para poder leer/procesar/escribir información en estos mismos.

[En este repositorio](https://github.com/public-apis/public-apis) van a encontrar una lista de APIs públicas (pueden elegir otras que no son de ese repositorio). Para la consigna, se recomienda usar aquellas APIs que no requieren autenticación. Si se elige una API con autenticación, por favor, adjuntar las keys o pasarl las credenciales necesarias para su futura ejecución También, pueden usar varias URLs.

## Consigna

Hacer una request GET e imprimir uno de los campos de la respuesta:
"""

import requests

url = "https://ar.pinterest.com/"
response = requests.get(url)


if response.status_code == 200:
    html_content = response.text
    print(html_content[:500])
else:
    print("Error en la solicitud:", response.status_code)

"""Hacer una request GET y, apartir de los campos en la respuesta, generar otro campo (por ejemplo, si la respuesta solo incluye un timestamp y una posición del registro, elaborar la velocidad del registro)"""

import requests
import time

url = "https://jsonplaceholder.typicode.com/posts"
response = None
try:
    response = requests.get(url)
    response.raise_for_status()
except requests.exceptions.RequestException as e:
    print(f"Error en la solicitud GET: {e}")


if response is not None:
    try:

        data = response.json()
    except ValueError:
        print("Error al intentar convertir la respuesta a JSON. Continuando con datos vacíos.")
        data = []


    if not data:
        print("No hay datos en la respuesta, continuando con el cálculo de velocidad.")
else:
    data = []
for i in range(1, len(data)):
    try:
        if 'id' in data[i] and 'id' in data[i - 1] and 'userId' in data[i] and 'userId' in data[i - 1]:
            timestamp_prev = data[i - 1]['id']
            timestamp_curr = data[i]['id']
            position_prev = data[i - 1]['userId']
            position_curr = data[i]['userId']

            time_diff = timestamp_curr - timestamp_prev
            position_diff = position_curr - position_prev


            if time_diff != 0:
                speed = position_diff / time_diff
            else:
                speed = 0
            print(f"Registro {i}: Velocidad = {speed} unidades por segundo")
        else:
            print(f"Registro {i}: Faltan campos necesarios para calcular la velocidad.")
    except KeyError as e:
        print(f"Error en el registro {i}: falta el campo {e}.")

"""# Streaming data
Ahora vamos a hacer algo muy parecido a lo anterior, pero vamos a usar APIs que nos ofrecen datos en tiempo real. Pueden encontrar APIs de este estilo [en este repositorio](https://github.com/ColinEberhardt/awesome-public-streaming-datasets) (pueden elegir otras que no son de ese repositorio)

## Consigna

Hacer un plot con `matplotlib` de una variable de una API de datos streaming en el que el eje 'y' sea la variable y el eje 'x' el tiempo.
"""

import requests
import matplotlib.pyplot as plt
from datetime import datetime

# URL de la API pública OpenNotify para obtener la ubicación de la ISS
url = "http://api.open-notify.org/iss-now.json"

# Hacer una única solicitud
response = requests.get(url)

if response.status_code == 200:
    data = response.json()  # Convertir la respuesta a JSON

    # Obtener la latitud y longitud de la ISS
    latitude = data['iss_position']['latitude']
    longitude = data['iss_position']['longitude']

    # Obtener el timestamp actual
    timestamp = datetime.now()

    # Mostrar los datos obtenidos
    print(f"Tiempo: {timestamp}, Latitud: {latitude}, Longitud: {longitude}")

    # Crear el gráfico con solo un punto
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.plot([timestamp], [latitude], 'bo', label='Latitud')
    ax.plot([timestamp], [longitude], 'ro', label='Longitud')

    # Personalizar el gráfico
    ax.set_xlabel('Tiempo')
    ax.set_ylabel('Posición')
    ax.set_title('Ubicación de la ISS en tiempo real')
    ax.legend()
    fig.autofmt_xdate()

    # Mostrar el gráfico
    plt.show()
else:
    print("Error al hacer la solicitud GET:", response.status_code)