# -*- coding: utf-8 -*-
"""Copia de POD - 04/Validación de datos/Individual -TERMINADO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zEm4ruQtlCLnjaKW8hfUQqKhIVEoWFpt

*   **Año:** 2024
*   **Alumno/a:** Sampayo Melanie
*   **Legajo:** [LEGAJO]

# Pydantic
Pydantic es una libreria rapida y extensible que nos permite validar datos usando tipos de datos de Python.

Primero, importe `pydantic`.
"""

import pydantic

"""Supongamos que tenemos una lista de clientes (llamemoslo en el codigo `Client`). Los clientes tienen dos campos: DNI (un entero) y nacionalidad (un `string`). Cree el modelo base de `Client` (en forma de clases de Python)."""

from pydantic import BaseModel
class Client(BaseModel):
  DNI:int
  nacionalidad:str

"""Cree a un usuario con documento 39.755.010 y nacionalidad 'Argentina'. Muestre todos sus campos."""

usuario=Client(DNI=39755010, nacionalidad="Argentina")
print(usuario)

"""Intente crear al usuario con un documento en forma de `string`. Deberia fallar..."""

usuario=Client(DNI="39755010", nacionalidad="Argentina")
print(usuario)

"""Hemos detectado que ciertos clientes tienen nacionalidades que no existen. Ademas, hay numeros de documento negativos y se tiene que poder agregar la fecha de registro de los clientes (que no pueden ser del futuro). Cambiar la definicion del cliente para que estas cosas no ocurran. Despues de la siguiente celda, cree otras 3 mas probando un caso donde deberia funcionar y otros dos en los que no."""

!pip install pycountry
from pydantic import BaseModel, validator, ValidationError
from datetime import date
import pycountry

class Client(BaseModel):
    DNI: int
    nacionalidad: str
    fecha_registro: date

    @validator('DNI')
    def dni_must_be_positive(cls, value):
        if value < 0:
            raise ValueError('DNI must be positive')
        return value

    @validator('nacionalidad')
    def nacionalidad_must_be_valid(cls, value):
        if not any(country.alpha_2 == value for country in pycountry.countries):
            raise ValueError(f'Nacionalidad "{value}" is not valid')
        return value

    @validator('fecha_registro')
    def registration_date_cannot_be_in_the_future(cls, value):
        if value > date.today():
            raise ValueError('Registration date cannot be in the future')
        return value

try:
    client_valid = Client(DNI=12345678, nacionalidad='AR', fecha_registro=date(2023, 5, 20))
    print("Caso válido:", client_valid)
except ValidationError as e:
    print(e)

try:
    client_invalid_dni = Client(DNI=-12345678, nacionalidad='AR', fecha_registro=date(2023, 5, 20))
except ValidationError as e:
    print("Caso inválido:", e)

try:
    client_invalid_nationality = Client(DNI=12345678, nacionalidad='ZZ', fecha_registro=date(2023, 5, 20))
except ValidationError as e:
    print("Caso inválido:", e)

"""# Pandera
Hacer lo que se pidio en la ultima celda anterior, pero con Pandera.
"""

import pandera as pa
from pandera import DataFrameSchema, Column, Check
import pycountry
from datetime import date
import pandas as pd

def validate_country(series: pd.Series) -> pd.Series:
    valid_countries = {country.alpha_2 for country in pycountry.countries}
    return series.isin(valid_countries)


schema = DataFrameSchema({
    "DNI": Column(int, Check(lambda x: x > 0, error="DNI must be positive")),
    "nacionalidad": Column(
        str,
        Check(validate_country, error="Invalid country code")
    ),
    "fecha_registro": Column(
        pa.DateTime,
        Check(lambda x: x <= pd.Timestamp(date.today()), error="Registration date cannot be in the future")
    ),
})

data = [
    {"DNI": 12345678, "nacionalidad": "AR", "fecha_registro": "2023-05-20"},  # Válido
    {"DNI": -12345678, "nacionalidad": "AR", "fecha_registro": "2023-05-20"},  # DNI negativo
    {"DNI": 12345678, "nacionalidad": "ZZ", "fecha_registro": "2023-05-20"},  # Nacionalidad inválida
    {"DNI": 12345678, "nacionalidad": "AR", "fecha_registro": "2025-01-01"},  # Fecha futura
]

df = pd.DataFrame(data)

df["fecha_registro"] = pd.to_datetime(df["fecha_registro"], errors="coerce")


try:
    validated_df = schema.validate(df, lazy=True)
    print("Todos los datos son válidos.")
    print(validated_df)
except pa.errors.SchemaErrors as e:
    print("Caso inválido:")
    print(e.failure_cases)