# -*- coding: utf-8 -*-
"""02/NumPy/Individual-terminado

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dqrqnnI7jqncp3OlEQY4bQ1cJoiSNHBO

*   **Año:** 2024
*   **Alumno/a:** Sampayo Melanie
*   **Legajo:** 1201633

# NumPy
A continuación, cada celda va a pedir algo distinto. Por favor, realizarlo con la menor cantidad de lineas posibles y con NumPy.

Importar `numpy` con el alias `np` e imprimir la versión instalada.
"""

import numpy as np
print(np.__version__)

"""Setear el "seed" de la librearia en 0."""

np.random.seed(0)

"""Crear un vector vacio (en ingles, *empty*) para subir 100 imagenes de 100x600 pixeles. Imprimir el shape de dicho vector."""

vector=np.empty((100,100,600))
print(vector.shape)

"""Crear dos vectores vacios donde uno tiene 1,000 elementos y el otro tiene 100,000 elementos. Imprimir el tamaño ocupado en memoria de cada arreglo en bytes."""

vector2 = np.empty(1000)
vector3 = np.empty(100000)
vector2.nbytes,vector3.nbytes

"""Crear un vector vacío con 10 elementos. El quinto elemento tiene que ser igual a 1. Imprimir el vector."""

vector4 = np.empty(10)
vector4[4]=1
vector4

"""Generar un arreglo con los valores desde 10 hasta 35 en pasos de 2. Imprimir el arreglo."""

d=np.arange(10,35,2)

"""Generar un arreglo con los valores desde -1 hasta -1 en pasos de 0.25. Luego, revertirlo. Imprimir el arreglo."""

d1=np.arange(-1,1,0.25)
d1[::-1]

"""Generar un arreglo que va desde -10 y 10 y que tenga 2,878 elementos. Imprimir el primer, último y 198º elemento."""

d2=np.linspace(-10,10,2878)
d2[0],d2[2877],d2[197]

"""Generar una matriz 5x5 y con valores de 0 a 24. Imprimir la matriz."""

ar=np.eye(5)

ar1=np.arange(0,25).reshape(5,5)
ar1

"""Generar una lista de 10,000 elementos que vengan de una distribucion uniforme entre la constante de euler y π. (Nota: utilizar constantes de `numpy`). Dibujar la distribución con `matplotlib` en forma de histograma e imprimir el tipo de dato del arreglo."""

import matplotlib.pyplot as plt
e=np.e
p=np.pi

random_generator_seed=np.random.default_rng()
two=np.random.uniform(e,p,10000)
two
plt.hist(two, bins = 50, density = True)
plt.show()

"""Generar una lista de 20 elementos que vengan de una distribucion uniforme entre 0 y 1 e imprimirlo ordenado."""

veinte=np.random.uniform(0,1,20)
veinte1=np.sort(veinte)
veinte1

"""Lo mismo que el punto anterior pero con una distribución normal con media 160 y desvío estandar 30."""

veinte=np.random.uniform(0,1,20)
veinte1=np.sort(veinte)
veinte1

"""Lo mismo que el punto anterior pero con una distribución normal con media 50 y desvío estandar 1. Imprimir el valor mas cercano (es decir, el de menor distancia) a 20 de los números generados."""

dis=np.random.normal(loc=50,scale=1,size=20)
dis2=np.sort(dis)
dis3=dis2-20
dis3

"""Teniendo en cuenta la declaración de la siguiente variable, imprimir la suma, la media, el máximo, y el mínimo de sus elementos."""

arreglo_dummy = np.array([1,9,10,23,45,78,94,78,10,23,65,47])
media=np.mean(arreglo_dummy)

suma=np.sum(arreglo_dummy)
max=np.max(arreglo_dummy)
minimo=np.min(arreglo_dummy)
media,suma,max,minimo

#Escribir el codigo para responder la pregunta en esta celda

"""Hacer lo mismo que el punto anterior pero... con un arreglo particular. Imprimir el resultado y encontrarle una explicación."""

arreglo_weird = np.array([1,9,10,23,45,78,94,np.nan,10,23,65,47])
suma=np.sum(arreglo_weird)
max=np.max(arreglo_weird)
minimo=np.min(arreglo_weird)
media=np.mean(arreglo_weird)
media,suma,max,minimo

#Escribir el codigo para responder la pregunta en esta celda

"""Generar un conjunto de 100 numeros ***enteros*** entre 0 y 10. Imprimir la cantidad de numeros pares que se generaron e imprimir el tipo de dato del arreglo."""

d2=np.random.randint(0,10,100)
d3=np.count_nonzero(d2%2==0)
d3

d2=np.random.randint(0,10,100)
d2
ls=[ ]
i=0
for x in d2:
  if (x %2)==0:
    i+=1
i

"""Generar un conjunto de 100 numeros enteros entre 0 y 10. Imprimir la cantidad de numeros mayores a 4 que se generaron."""

d2=np.random.randint(0,10,100)
d3=np.count_nonzero(d2>4)
d3

d2=np.random.randint(0,10,100)
d2
ls=[ ]
i=0
for x in d2:
  if x>4:
    ls.append(x)
ls

"""Generar un conjunto de 100 numeros enteros entre 0 y 10. Imprimir la cantidad de numeros mayores a 6 e impares que se generaron."""

d2=np.random.randint(0,10,100)
d3=np.count_nonzero(d2>6)
d4=np.count_nonzero(d2%2!=0)
d3,d4

"""Supongamos que hay elecciones nacionales en un país y la cantidad de votos fueron los siguientes:


|Candidato 1|Cantidato 2|Cantidato 3|
|--|--|--|
|1,772,322  |1,102,669|2,100,978 |

Con `numpy`, calcular el porcentaje correspondiente a cada candidato y redondear a 2 dígitos. Imprimir los porcentajes finales y el numero del candidato ganador (aunque sea obvio, responder con lógica de `numpy`).
"""

suma=1772332+1102669+2100978
can1=(1772322*100)/suma
can2=(1102669*100)/suma
can3=(2100978*100)/suma
uno=round(can1,2)
dos=round(can2,2)
tres=round(can3,2)
c=uno,dos,tres
maximo=np.max(c)
uno,dos,tres,maximo

"""Generar un arreglo de 1,000 numeros de una distribución uniforme entre 0 y 1. Luego, generar otro arreglo que contenga todos los numeros del primer arreglo que son mayores a 0.7. Imprimir la media del "sub" arreglo."""

s = np.random.uniform(low=0,high=1,size=1000)
d3=np.count_nonzero(s>0.7)
ar=arr
p=np.mean(d3)
d3

"""# Operación vectorizada vs. Operación loopeada
`numpy` no es solo poderoso por la gama de operaciones que podemos hacer en pocas lineas de código. Sino que por su eficiencia.

Supongamos que tenemos la función $f(x)=10*(x^2/e^x)$. Evaluar la función (en celdas apartes) entre -1 y 1 con 100,000 valores (i) con y (ii) sin un loop `for`. Medir tiempos de cada celda y sacar conclusiones.
"""

import time
def f(x):
    return 10 * (x**2 / np.exp(x))
x_val = np.linspace(-1, 1, 100000)
time1 = time.time()
x1= []
for x in x1:
    y_val.append(f(x))
time2 = time.time()
print(time2-time1)

import time

def f(x):
    return 10 * (x**2 / np.exp(x))

inicio = time.time()
y_val = f(x_val)
fin = time.time()
print(fin - inicio)

"""El resultado de la celda anterior (aprovechar lo obtenido), graficarlo como gráfico de lineas."""

import matplotlib.pyplot as plt

plt.hist(y_val, bins = 50, density = True)
plt.show()

"""# Análisis de imagenes

Matematicamente hablando, las imagenes son arreglos. Si una imagen es de blanco y negro, tenemos una imagen de un canal y puede ser interpretado como una simple matriz (`.shape=2`). Si tiene varios canales, tenemos una matriz asignada para cada canal (`.shape=3`).

[Lenna](https://en.wikipedia.org/wiki/Lenna) es una imagen ampliamente utilizada en ciencias de la computación. Se volvió un icono. La idea va a ser analizar a la imagen y tratarla para varios propositos. Corra la siguiente celda para descargar la imagen y guardala como arreglo `numpy` en la variable `image`. Utilizar esta variable en las siguientes celdas.
"""

!wget https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png
from PIL import Image
image = Image.open('Lenna_(test_image).png')
image = np.asarray(image)

"""Arranquemos con mostrar la imagen. Para eso, utilice `matplotlib.pyplot`."""

import matplotlib.pyplot as plt
plt.imshow(image)

"""¿Cual es la dimensión de la imagen y que ancho y alto tiene?"""

np.shape(image)

"""Recorte la imagen en ancho entre (tomando como referencia los ejes de la imagen vista anteriormente) los 100 y 350 pixeles y en alto entre 200 y 400 pixeles. Mostrar el resultado."""

imagecortada = image[200:400, 100:350]

plt.imshow(imagecortada)
plt.title('Imagen Recortada')
plt.show()

"""Muestre cada uno de los canales de la imagen."""

R = image[:, :, 0]
G = image[:, :, 1]
B = image[:, :, 2]

plt.subplot(1, 3, 1)
plt.imshow(B, cmap='gray')
plt.title("Azul")

plt.subplot(1, 3, 2)
plt.imshow(G, cmap='gray')
plt.title("Verde")

plt.subplot(1, 3, 3)
plt.imshow(R, cmap='gray')
plt.title("Rojo")

"""Calcule el minimo, el máximo, y el promedio de los valores de la imagen."""

u=np.max(image)
d=np.min(image)
t=np.mean(image)
print(u,d,t)

"""La verdad que tener todos los colores de la imagen es muy redundante. Paselo a blanco y negro. Para ello, tome el promedio de los canales en cada pixel. Muestre la imagen en blanco y negro."""

white= np.mean(image, axis=2)
plt.imshow(white, cmap='gray')
plt.title("Imagen en Blanco y Negro")
plt.show()

"""Por último, vamos a proceder a "binarizar" la imagen. Es decir, vamos a setear en 1 TODOS los pixeles donde la intensidad (es decir, el valor del pixel) sea mayor a 200. El resto, lo seteamos a 0. Mostrar el resultado."""

binaria = (white > 200).astype(np.uint8)
plt.imshow(binaria, cmap='gray')

plt.show()

"""# Análisis de datos

`boston.csv` es un archivo csv ampliamente utilizado como 'juguete' en proyectos de Machine Learning. Para descargarlo, corra la siguiente celda.
"""

!wget https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/csv/MASS/Boston.csv

"""Lea el archivo csv (sin `pandas` pero se puede usar `csv`) y quedese con todas las columnas que son numericas. Inspeccionarlo puede hacer el trabajo bastante facil.

Nota: Aunque `numpy` tenga una libreria para leer archivos, en este caso no no es útil por que todas las columas constan de diferentes tipo de dato y ademas el encabezado es `string`.
"""

import csv
def extraer_columnas_numericas(archivo_csv):
  columnas_numericas = []
  with open(archivo_csv, 'r') as csvfile:
    lector = csv.reader(csvfile)
    encabezados = next(lector)

    for fila in lector:
      fila_num = []
      for i, valor in enumerate(fila):
        try:
          valor_numerico = float(valor)
          fila_num.append(valor_numerico)
        except ValueError:
         pass
      columnas_numericas.append(fila_num)

  return columnas_numericas


archivo = 'Boston.csv'
datos_numericos = extraer_columnas_numericas(archivo)


for fila in datos_numericos:
  print(fila)

"""Una vez procesado el archivo csv, proceda a convertirlo en una matriz de `numpy`."""

import numpy as np
matriz_numpy = np.array(datos_numericos)
print(matriz_numpy)

"""Reporte el promedio de todas las columnas."""

promedios= np.mean(matriz_numpy, axis=0)
print(promedios)

"""Reporte la división entre una columna y otra (a elección cuales)"""

columna_1 = matriz_numpy[:, 0]
columna_2 = matriz_numpy[:, 1]


resultado_division = columna_1 / columna_2

print("Resultado de la división (columna 1 / columna 2):")
print(resultado_division)